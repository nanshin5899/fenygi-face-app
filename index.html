<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>äººè‡‰æ‰“å¡ç³»çµ± v2.1</title>
    <style>
        body { font-family: sans-serif; text-align: center; margin: 0; background: #f0f0f0; }
        #video-container { position: relative; margin: 20px auto; width: 320px; height: 240px; background: #000; border: 3px solid #333; }
        video { width: 100%; height: 100%; object-fit: cover; }
        canvas { position: absolute; top: 0; left: 0; }
        .controls { margin: 15px; padding: 10px; background: #ddd; border-radius: 8px; max-width: 340px; margin-left: auto; margin-right: auto; }
        input { padding: 8px; border-radius: 5px; border: 1px solid #ccc; width: 60%; }
        button { padding: 8px 15px; margin: 5px; border: none; border-radius: 5px; cursor: pointer; color: white; font-weight: bold;}
        .btn-reg { background: #007bff; }
        .btn-csv { background: #28a745; }
        .btn-clear { background: #dc3545; }
        button:disabled { background: #ccc; }
        #status { margin-top: 10px; font-weight: bold; color: #333; min-height: 20px;}
        #log { margin-top: 10px; text-align: left; padding: 10px; background: white; max-width: 300px; margin-left: auto; margin-right: auto; height: 150px; overflow-y: scroll; border: 1px solid #ccc;}
    </style>
    <script src="https://cdn.jsdelivr.net/npm/face-api.js@0.22.2/dist/face-api.min.js"></script>
</head>
<body>

    <h2>äººè‡‰æ‰“å¡ç³»çµ± (å«å„²å­˜åŠŸèƒ½)</h2>
    
    <div id="status">æ­£åœ¨è¼‰å…¥ AI æ¨¡å‹...</div>

    <div id="video-container">
        <video id="video" autoplay muted playsinline></video>
    </div>

    <div class="controls">
        <input type="text" id="nameInput" placeholder="è¼¸å…¥å“¡å·¥å§“å">
        <button id="registerBtn" class="btn-reg" onclick="registerFace()" disabled>è¨»å†Šé€™å¼µè‡‰</button>
        <br><br>
        <button class="btn-csv" onclick="downloadCSV()">ğŸ“¥ ä¸‹è¼‰ Excel</button>
        <button class="btn-clear" onclick="clearAllData()">ğŸ—‘ï¸ æ¸…é™¤è³‡æ–™</button>
    </div>

    <h3>ä»Šæ—¥æ‰“å¡ç´€éŒ„ï¼š</h3>
    <div id="log"></div>

    <script>
        const video = document.getElementById('video');
        const status = document.getElementById('status');
        const registerBtn = document.getElementById('registerBtn');
        const logDiv = document.getElementById('log');
        
        let labeledDescriptors = []; 
        let faceMatcher; 
        let checkInLogs = []; 

        // 1. å•Ÿå‹•æµç¨‹
        Promise.all([
            faceapi.nets.tinyFaceDetector.loadFromUri('https://justadudewhohacks.github.io/face-api.js/models'),
            faceapi.nets.faceLandmark68Net.loadFromUri('https://justadudewhohacks.github.io/face-api.js/models'),
            faceapi.nets.faceRecognitionNet.loadFromUri('https://justadudewhohacks.github.io/face-api.js/models')
        ]).then(async () => {
            await loadLocalData(); 
            startVideo();
        }).catch(err => {
            status.innerText = "æ¨¡å‹è¼‰å…¥å¤±æ•—";
            console.error(err);
        });

        // 2. å•Ÿå‹•æ”å½±æ©Ÿ (ä¿®æ­£é¡¯ç¤ºæ–‡å­—çš„éƒ¨åˆ†)
        function startVideo() {
            navigator.mediaDevices.getUserMedia({ video: {} })
                .then(stream => {
                    video.srcObject = stream;
                    
                    // é€™è£¡åšäº†ä¿®æ”¹ï¼šåˆ¤æ–·æ˜¯å¦æœ‰äººæ•¸ï¼Œé¡¯ç¤ºå°æ‡‰æ–‡å­—
                    const count = labeledDescriptors.length;
                    if (count > 0) {
                        status.innerText = `ç³»çµ±å°±ç·’ï¼(å·²è¼‰å…¥ ${count} ä½å“¡å·¥è³‡æ–™)`;
                    } else {
                        status.innerText = "ç³»çµ±å°±ç·’ï¼(ç›®å‰ç„¡è³‡æ–™ï¼Œè«‹å…ˆè¨»å†Š)";
                    }

                    registerBtn.disabled = false;
                    startRecognition(); 
                })
                .catch(err => {
                    status.innerText = "ç„¡æ³•é–‹å•Ÿæ”å½±æ©Ÿ (è«‹ç¢ºèª HTTPS)";
                });
        }

        // 3. è®€å– LocalStorage
        async function loadLocalData() {
            const localFaces = localStorage.getItem('myFaceData');
            const localLogs = localStorage.getItem('myFaceLogs');

            if (localLogs) {
                checkInLogs = JSON.parse(localLogs);
                checkInLogs.forEach(logText => {
                    const div = document.createElement('div');
                    div.innerText = logText;
                    logDiv.prepend(div);
                });
            }

            if (localFaces) {
                const parsed = JSON.parse(localFaces);
                labeledDescriptors = parsed.map(d => {
                    const descriptors = d.descriptors.map(arr => new Float32Array(arr));
                    return new faceapi.LabeledFaceDescriptors(d.label, descriptors);
                });

                if (labeledDescriptors.length > 0) {
                    faceMatcher = new faceapi.FaceMatcher(labeledDescriptors, 0.6);
                }
            }
        }

        // 4. å„²å­˜è³‡æ–™
        function saveToLocal() {
            const serializableFaces = labeledDescriptors.map(ld => ({
                label: ld.label,
                descriptors: ld.descriptors.map(d => Array.from(d))
            }));
            localStorage.setItem('myFaceData', JSON.stringify(serializableFaces));
            localStorage.setItem('myFaceLogs', JSON.stringify(checkInLogs));
        }

        // 5. è¨»å†Šäººè‡‰
        async function registerFace() {
            const name = document.getElementById('nameInput').value;
            if (!name) { alert("è«‹è¼¸å…¥å§“åï¼"); return; }

            status.innerText = "æ­£åœ¨æƒæç‰¹å¾µ...";
            const detection = await faceapi.detectSingleFace(video, new faceapi.TinyFaceDetectorOptions()).withFaceLandmarks().withFaceDescriptor();

            if (detection) {
                labeledDescriptors.push(new faceapi.LabeledFaceDescriptors(name, [detection.descriptor]));
                faceMatcher = new faceapi.FaceMatcher(labeledDescriptors, 0.6);
                
                // è¨»å†ŠæˆåŠŸå¾Œï¼Œæ›´æ–°ç‹€æ…‹æ–‡å­—
                status.innerText = `è¨»å†ŠæˆåŠŸï¼š${name} (ç›®å‰å…± ${labeledDescriptors.length} äºº)`;
                alert(`å·²è¨˜ä½ ${name}`);
                document.getElementById('nameInput').value = '';
                
                saveToLocal(); 
            } else {
                alert("æ²’æŠ“åˆ°è‡‰ï¼Œè«‹å°æº–é¡é ­");
                status.innerText = "è¨»å†Šå¤±æ•—ï¼Œè«‹é‡è©¦";
            }
        }

        // 6. è¾¨è­˜èˆ‡æ‰“å¡
        let lastLogTime = 0;
        let lastLogName = "";

        async function startRecognition() {
            const canvas = faceapi.createCanvasFromMedia(video);
            document.getElementById('video-container').append(canvas);
            const displaySize = { width: video.width || 320, height: video.height || 240 };
            faceapi.matchDimensions(canvas, displaySize);

            setInterval(async () => {
                if (!faceMatcher) return;

                const detections = await faceapi.detectAllFaces(video, new faceapi.TinyFaceDetectorOptions()).withFaceLandmarks().withFaceDescriptors();
                const resizedDetections = faceapi.resizeResults(detections, displaySize);
                canvas.getContext('2d').clearRect(0, 0, canvas.width, canvas.height);

                const results = resizedDetections.map(d => faceMatcher.findBestMatch(d.descriptor));

                results.forEach((result, i) => {
                    const box = resizedDetections[i].detection.box;
                    const drawBox = new faceapi.draw.DrawBox(box, { label: result.toString() });
                    drawBox.draw(canvas);

                    if (result.label !== 'unknown') {
                        recordCheckIn(result.label);
                    }
                });
            }, 500);
        }

        function recordCheckIn(name) {
            const now = new Date();
            if (name === lastLogName && (now - lastLogTime) < 10000) return;

            lastLogTime = now;
            lastLogName = name;
            
            const timeString = now.toLocaleString();
            const logText = `[${timeString}] ${name}`;
            
            const div = document.createElement('div');
            div.innerText = logText;
            logDiv.prepend(div);
            
            // é€™è£¡ä¹Ÿä¿®æ­£ï¼šè¾¨è­˜æˆåŠŸå¾Œï¼Œä¿æŒé¡¯ç¤ºç›®å‰äººæ•¸ç‹€æ…‹
            status.innerText = `æ­¡è¿ï¼ ${name} (å·²è¨˜éŒ„)`;

            checkInLogs.push(logText);
            saveToLocal();
        }

        // 7. åŒ¯å‡º CSV
        function downloadCSV() {
            if (checkInLogs.length === 0) {
                alert("ç›®å‰æ²’æœ‰ä»»ä½•æ‰“å¡ç´€éŒ„ï¼");
                return;
            }
            let csvContent = "\uFEFFæ™‚é–“,å§“å\n"; 
            checkInLogs.forEach(log => {
                csvContent += log.replace('] ', '],') + "\n";
            });

            const blob = new Blob([csvContent], { type: "text/csv;charset=utf-8;" });
            const link = document.createElement("a");
            const url = URL.createObjectURL(blob);
            link.setAttribute("href", url);
            link.setAttribute("download", "æ‰“å¡ç´€éŒ„.csv");
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        function clearAllData() {
            if(confirm("ç¢ºå®šè¦åˆªé™¤æ‰€æœ‰è¨»å†Šçš„è‡‰å’Œç´€éŒ„å—ï¼Ÿç„¡æ³•å¾©åŸå–”ï¼")) {
                localStorage.clear();
                location.reload(); 
            }
        }
    </script>
</body>
</html>